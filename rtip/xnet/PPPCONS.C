/* PPPCONS.C - PPP CONSTANT GLOBAL DATA                                 */
/*                                                                      */
/* EBS - RTIP                                                           */
/*                                                                      */
/* Copyright Peter Van Oudenaren , 1993                                 */
/* All rights reserved.                                                 */
/* This code may not be redistributed in source or linkable object form */
/* without the consent of its author.                                   */
/*                                                                      */
/*  Module description:                                                 */
/*      This module contains all the global data for PPP                */
/*      which is never modified.                                        */
/*                                                                      */
/*  Revision History:                                                   */
/*  11/98      Initial coding                                           */
/*                                                                      */

#define DIAG_SECTION_KERNEL DIAG_SECTION_PPP


#include "sock.h"
#include "rtip.h"

#if (INCLUDE_RTIP)
#if (INCLUDE_PPP)

/* ********************************************************************   */
/* PPPAPI                                                                 */
/* ********************************************************************   */

RTIP_BOOLEAN ppp_open(PIFACE pi);
void    ppp_close(PIFACE pi);
int     ppp_xmit(PIFACE pi, DCU msg);
RTIP_BOOLEAN ppp_statistics(PIFACE  pi);

#if (PPP_TX_PACKET_TYPE)
int ppp_xmit_pkt(PIFACE pi, DCU msg);
RTIP_BOOLEAN ppp_xmit_done(PIFACE pi, DCU msg, RTIP_BOOLEAN success);
#endif

#if (PPP_TX_PACKET_TYPE)
EDEVTABLE KS_FAR ppp_device = 
{
    ppp_open, ppp_close, ppp_xmit_pkt, ppp_xmit_done,
    NULLP_FUNC, ppp_statistics, NULLP_FUNC, 
    PPP_DEVICE, "PPP-UART", MINOR_0, RS232_IFACE, 
    SNMP_DEVICE_INFO(CFG_OID_PPP, 0)
    CFG_RS232_MAX_MTU, CFG_RS232_MAX_MSS, 
    CFG_RS232_MAX_WIN_IN, CFG_RS232_MAX_WIN_OUT, 
    IOADD(DFLT_PORT), EN(96), EN('N')
};
#else
EDEVTABLE KS_FAR ppp_device = 
{
    ppp_open, ppp_close, ppp_xmit, rs232_xmit_done,
    NULLP_FUNC, ppp_statistics, NULLP_FUNC, 
    PPP_DEVICE, "PPP-UART", MINOR_0, RS232_IFACE, 
    SNMP_DEVICE_INFO(CFG_OID_PPP, 0)
    CFG_RS232_MAX_MTU, CFG_RS232_MAX_MSS, 
    CFG_RS232_MAX_WIN_IN, CFG_RS232_MAX_WIN_OUT, 
    IOADD(DFLT_PORT), EN(96), EN('N')
};
#endif

/* ********************************************************************   */
/* PPP                                                                    */
/* ********************************************************************   */

/*
 * FCS lookup table as generated by fcsgen.c
 */
KS_GLOBAL_CONSTANT word KS_FAR fcstab[256] = 
{
    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/* dummy ethernet address used to fake IP layer   */
KS_GLOBAL_CONSTANT byte KS_FAR dummy_en_addr[ETH_ALEN] = {0x1,0x2,0x3,0x4,0x5,0x6};

/* ********************************************************************   */
/* PPPFSM                                                                 */
/* ********************************************************************   */

/* ********************************************************************   */
/* PPPLCP                                                                 */
/* ********************************************************************   */
DCU  lcp_makereq(PFSMS fsm_p);
int  lcp_request(PFSMS fsm_p,   PCONFIG_HDR config, DCU msg);
int  lcp_ack(PFSMS fsm_p, PCONFIG_HDR ackcnf, DCU msg);
int  lcp_nak(PFSMS fsm_p, PCONFIG_HDR nakcnf, DCU msg);
int  lcp_reject(PFSMS fsm_p, PCONFIG_HDR rejcnf, DCU msg);
void lcp_reset(PFSMS fsm_p);
void lcp_starting(PFSMS fsm_p);
void lcp_stopping(PFSMS fsm_p);
void lcp_closing(PFSMS fsm_p);
void lcp_opening(PFSMS fsm_p);
void lcp_free(PFSMS fsm_p);

/* parameters will negotiate (i.e. will not reject)   */
KS_GLOBAL_CONSTANT word KS_FAR lcp_negotiate = LCP_N_MRU | LCP_N_ACCM | 
                                        LCP_N_AUTHENT | LCP_N_PFC | 
                                        LCP_N_ACFC | LCP_N_MAGIC;

/* default values for LCP options                                         */
/* these defaults are defined in the PPP RFCs, and must not be changed    */
PPP_GLOBAL_CONSTANT struct lcp_value_s KS_FAR lcp_default =  
{
    FALSE,          /* no need to negotiate defaults */

    CFG_LCP_MRU_DFLT,
    CFG_LCP_ACCM_DFLT,
    0,              /* no authentication */
#if (INCLUDE_CHAP)
    MD5_ALGORITHM,  /* only supports MD5 */
#endif
    0,              /* no encryption */
    0L,             /* no magic number */
    0L,             /* no reporting period */
};

KS_GLOBAL_CONSTANT byte KS_FAR lcp_option_length[LCP_OPTION_LIMIT+1] = 
{
     0,     /* unused */
     4,     /* MRU */
     6,     /* ACCM */
     4,     /* authentication: PAP=4, CHAP=5 */
     4,     /* encryption */
     6,     /* magic number */
     6,     /* monitor reporting period */
     2,     /* Protocol compression */
     2      /* Address/Control compression */
};

/* LCP constants - contains values as well as routines to call when   */
/*                 events occur                                       */
PPP_GLOBAL_CONSTANT struct fsm_constant_s KS_FAR lcp_constants = 
{
    PPP_LCP_PROTOCOL,
    0x0FFE,             /* codes 1-11 recognized */

    Lcp,
    _CFG_LCP_REQ_TRY,
    _CFG_LCP_NAK_TRY,
    _CFG_LCP_TERM_TRY,
    _CFG_LCP_TIMEOUT,

    lcp_free,

    lcp_reset,
    lcp_starting,
    lcp_opening,
    lcp_closing,
    lcp_stopping,

    lcp_makereq,
    lcp_request,
    lcp_ack,
    lcp_nak,
    lcp_reject
};


/* ********************************************************************   */
/* PPPIPCP                                                                */
/* ********************************************************************   */
DCU ipcp_makereq(PFSMS fsm_p);

int ipcp_request    (PFSMS fsm_p, PCONFIG_HDR config, DCU msg);
int ipcp_ack    (PFSMS fsm_p, PCONFIG_HDR config, DCU msg);
int ipcp_nak    (PFSMS fsm_p, PCONFIG_HDR config, DCU msg);
int ipcp_reject(PFSMS fsm_p,    PCONFIG_HDR config, DCU msg);

void ipcp_reset(PFSMS fsm_p);

void ipcp_starting(PFSMS fsm_p);
void ipcp_stopping(PFSMS fsm_p);

void ipcp_closing(PFSMS fsm_p);
void ipcp_opening(PFSMS fsm_p);

void ipcp_free(PFSMS fsm_p);

/***********************************************************************  */
/* These defaults are defined in the PPP RFCs, and must not be changed    */
KS_GLOBAL_CONSTANT struct ipcp_value_s KS_FAR ipcp_default = 
{
    FALSE,      /* no need to negotiate defaults */

    {0,0,0,0},  /* no source address */
    {0,0,0,0},  /* no destination address */
#if (INCLUDE_PPP_DNS)
    {0,0,0,0},  /* dns primary address */
    {0,0,0,0},  /* dns secondary address */
#endif
    0,          /* no compression protocol */
    0,          /* no slots */
    0           /* no slot compression */
};

/* Options to accept in NAK(local) or REQ(remote) - everything we                   */
/* understand is set                                                                */
/*KS_GLOBAL_CONSTANT word KS_FAR ipcp_negotiate = IPCP_N_ADDRESS | IPCP_N_COMPRESS; */
KS_GLOBAL_CONSTANT word KS_FAR ipcp_negotiate = IPCP_N_ADDRESS        | 
                                         IPCP_N_DNS_PRIMARY    |
                                         IPCP_N_DNS_SECOND;

KS_GLOBAL_CONSTANT byte KS_FAR ipcp_option_length[IPCP_OPTION_LIMIT+1] = 
{
     0,     /* unused */
    10,     /* addresses */
     6,     /* compression */
     6,     /* address */
#if (INCLUDE_PPP_DNS)
     6,     /* DNS primary */
     6      /* DNS secondary */
#endif
};


PPP_GLOBAL_CONSTANT struct fsm_constant_s KS_FAR ipcp_constants = 
{
    PPP_IPCP_PROTOCOL,
    0x00FE,             /* codes 1-7 recognized */

    IPcp,
    _CFG_IPCP_REQ_TRY,
    _CFG_IPCP_NAK_TRY,
    _CFG_IPCP_TERM_TRY,
    _CFG_IPCP_TIMEOUT,

    ipcp_free,

    ipcp_reset,
    ipcp_starting,
    ipcp_opening,
    ipcp_closing,
    ipcp_stopping,

    ipcp_makereq,
    ipcp_request,
    ipcp_ack,
    ipcp_nak,
    ipcp_reject,
};


/* ********************************************************************   */
/* PPPPAP                                                                 */
/* ********************************************************************   */

/* message sent in Config-ACK and Config-NAK PAP messages             */
/* NOTE: there must be a space at the beginning of the string (leaves */
/*       room for the length of the string)                           */
KS_GLOBAL_CONSTANT char KS_FAR welcome_msg[9]       = " Welcome";
KS_GLOBAL_CONSTANT char KS_FAR invalid_msg[30]      = " Invalid username or password";
#if (INCLUDE_CHAP)
KS_GLOBAL_CONSTANT char KS_FAR invalid_chap_msg[27] = " Invalid CHAP Response-Bye";
#endif

#if (INCLUDE_PAP)
DCU pap_makereq(PFSMS fsm_p);
void pap_free(PFSMS fsm_p);

PPP_GLOBAL_CONSTANT struct fsm_constant_s KS_FAR pap_constants = 
{
    PPP_PAP_PROTOCOL,            
    0x000E,             /* codes 1-3 recognized:
                           1=Authenticate-Request
                           2=Authenticate-Ack
                           3=Authenticate-Nak */

    Pap,
    _CFG_PAP_REQ_TRY,   /* try_req */
    _CFG_PAP_FAIL_MAX,  /* try_nak */
    0,                  /* try_term */
    _CFG_PAP_TIMEOUT,

    pap_free,

    fsm_no_action,      /* pap_reset, */
    fsm_no_action,      /* pap_starting, */
    fsm_no_action,      /* pap_opening, */
    fsm_no_action,      /* pap_closing, */
    fsm_no_action,      /* pap_stopping, */

    pap_makereq,
    fsm_no_check,       /* pap_request, */
    fsm_no_check,       /* pap_ack, */
    fsm_no_check,       /* pap_nak, */
    fsm_no_check,       /* pap_reject */
};
#endif

#if (INCLUDE_CHAP)
/* ********************************************************************   */
/* PPPCHAP                                                                */
/* ********************************************************************   */

DCU  chap_makereq(PFSMS fsm_p);
void chap_free(PFSMS fsm_p);

PPP_GLOBAL_CONSTANT struct fsm_constant_s KS_FAR chap_constants = 
{
    PPP_CHAP_PROTOCOL,           
    /* tbd - is this even used???   */
    0x000E,             /* codes 1-3 recognized:
                           1=challenge
                           2=response
                           3=success
                           4=failure*/

    Chap,
    _CFG_CHAP_REQ_TRY,
    0,
    0,
    _CFG_CHAP_TIMEOUT,

    chap_free,

    fsm_no_action,      /* chap_reset, */
    fsm_no_action,      /* chap_starting, */
    fsm_no_action,      /* chap_opening, */
    fsm_no_action,      /* chap_closing, */
    fsm_no_action,      /* chap_stopping, */

    chap_makereq,
    fsm_no_check,       /* chap_request, */
    fsm_no_check,       /* chap_ack, */
    fsm_no_check,       /* chap_nak, */
    fsm_no_check,       /* chap_reject */
};
#endif

/* ********************************************************************   */
/* PPPUSER                                                                */
/* ********************************************************************   */

#endif /*INCLUDE_PPP */
#endif /*INCLUDE_RTIP */
